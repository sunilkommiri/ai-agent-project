<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Agent Platform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Google Sans', 'Inter', sans-serif;
            background-color: #f0f4f9;
        }
        .dark body {
            background-color: #131314;
        }
        /* Custom scrollbar for a more polished look */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #d4d4d4; border-radius: 10px; }
        .dark ::-webkit-scrollbar-thumb { background: #4a5568; }
        ::-webkit-scrollbar-thumb:hover { background: #a3a3a3; }
        .dark ::-webkit-scrollbar-thumb:hover { background: #718096; }

        .chat-message {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s ease-out forwards;
        }
        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        #chat-input:focus {
            box-shadow: none;
        }
        .gemini-gradient-text {
            background: -webkit-linear-gradient(45deg, #4285f4, #9b72cb, #d96570, #f2a600);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
         .sidebar-item.active {
            background-color: #e8f0fe;
        }
        .dark .sidebar-item.active {
            background-color: #1e1f20;
        }
        /* Thinking dots animation */
        .thinking-dots span {
            animation-name: blink;
            animation-duration: 1.4s;
            animation-iteration-count: infinite;
            animation-fill-mode: both;
        }
        .thinking-dots span:nth-child(2) {
            animation-delay: .2s;
        }
        .thinking-dots span:nth-child(3) {
            animation-delay: .4s;
        }
        @keyframes blink {
            0% { opacity: .2; }
            20% { opacity: 1; }
            100% { opacity: .2; }
        }
    </style>
</head>
<body class="bg-white dark:bg-[#131314]">

    <div class="flex h-screen text-gray-800 dark:text-gray-100">
        <!-- Sidebar -->
        <aside class="w-64 bg-gray-100 dark:bg-[#1e1f20] flex flex-col p-2 space-y-2">
            <button id="new-chat-btn" class="flex items-center w-full p-2 text-left text-sm rounded-full hover:bg-gray-200 dark:hover:bg-[#2d2e30] transition-colors font-medium">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                New Chat
            </button>
            <div class="flex-grow pt-4 overflow-y-auto">
                <h2 class="px-2 text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">Recent</h2>
                <div id="chat-history-list" class="space-y-1">
                    <!-- Chat history will be populated here -->
                </div>
            </div>
             <div class="border-t border-gray-200 dark:border-gray-700 p-2">
                <a href="#" class="flex items-center w-full p-2 text-left text-sm rounded-lg hover:bg-gray-200 dark:hover:bg-[#2d2e30] transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-4 h-4 mr-2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                    User Profile
                </a>
            </div>
        </aside>

        <!-- Main Chat Area -->
        <main class="flex-1 flex flex-col bg-white dark:bg-[#131314]">
            <div id="chat-container" class="flex-1 overflow-y-auto p-4 md:p-6">
                <div id="chat-log" class="max-w-3xl mx-auto space-y-6">
                <!-- Chat messages will be dynamically added here -->
                </div>
            </div>

            <!-- Input Area -->
            <div class="px-4 md:px-6 py-4">
                <div class="max-w-3xl mx-auto">
                     <form id="chat-form" class="relative">
                        <div id="image-preview-container" class="hidden absolute bottom-full left-0 mb-2">
                             <div class="relative">
                                <img id="image-preview" src="" alt="Image preview" class="max-h-24 rounded-lg border border-gray-300 dark:border-gray-700">
                                <button id="remove-image-btn" type="button" class="absolute -top-2 -right-2 bg-red-500 text-white rounded-full h-5 w-5 flex items-center justify-center text-xs border-2 border-white dark:border-gray-800">&times;</button>
                            </div>
                        </div>
                        <div class="flex items-center p-2 rounded-full border border-gray-300 dark:border-gray-700 bg-gray-100 dark:bg-[#1e1f20]">
                            <textarea id="chat-input" class="flex-1 bg-transparent border-none focus:ring-0 resize-none p-2 text-gray-800 dark:text-gray-100" placeholder="Ask the agent anything..." rows="1"></textarea>
                            <button id="attach-file-btn" type="button" class="p-2 text-gray-500 hover:text-gray-700 dark:hover:text-gray-300 rounded-full hover:bg-gray-200 dark:hover:bg-gray-600">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
                            </button>
                            <input type="file" id="image-upload" accept="image/*" class="hidden">
                             <button id="send-btn" type="submit" class="p-2 rounded-full bg-blue-600 text-white hover:bg-blue-700 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:cursor-not-allowed">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                            </button>
                        </div>
                    </form>
                    <p class="text-xs text-center text-gray-500 mt-2">This is a demo AI agent. Responses may not always be accurate.</p>
                </div>
            </div>
        </main>
    </div>

    <script type="module">
        // --- API Configuration ---
        // PASTE YOUR API GATEWAY INVOKE URL HERE
        const API_BASE_URL = "https://h6l0hhe0b0.execute-api.us-east-1.amazonaws.com/Dev";

        // --- State Management ---
        let conversations = {};
        let activeConversationId = null;
        let currentImageData = null;

        // --- DOM Elements ---
        const chatLog = document.getElementById('chat-log');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const attachFileBtn = document.getElementById('attach-file-btn');
        const imageUpload = document.getElementById('image-upload');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const imagePreview = document.getElementById('image-preview');
        const removeImageBtn = document.getElementById('remove-image-btn');
        const newChatBtn = document.getElementById('new-chat-btn');
        const chatHistoryList = document.getElementById('chat-history-list');

        // --- Core Agent Logic ---
        async function runAgent(userInput, imageData) {
            const currentConversation = conversations[activeConversationId];
            
            const userMessage = { role: 'user', text: userInput };
            addChatMessage(userMessage);
            currentConversation.history.push({ role: 'user', parts: [{ text: userInput }] });
            
            if (currentConversation.history.length === 1 && currentConversation.title === "New Chat") {
                currentConversation.title = userInput.substring(0, 30) + (userInput.length > 30 ? '...' : '');
                renderSidebar();
            }

            addChatMessage({ role: 'agent', thinking: true });

            const routerPrompt = buildRouterPrompt(userInput, imageData, currentConversation.history);
            const rawDecision = await callGeminiText("gemini-2.0-flash", routerPrompt, 0.1);
            
            let decision;
            try {
                const jsonString = rawDecision.match(/```json\n([\s\S]*?)\n```/)[1];
                decision = JSON.parse(jsonString);
            } catch (e) {
                updateLastMessage("I had trouble understanding that. Could you rephrase?");
                return;
            }

            let finalResponse;
            if (decision.action === 'chat') {
                finalResponse = decision.response;
            } else if (decision.action === 'vision') {
                updateLastMessage('Analyzing image...', true);
                finalResponse = await callGeminiVision("gemini-2.0-flash", userInput, imageData.mimeType, imageData.base64);
            } else if (decision.action === 'tool_use') {
                updateLastMessage(`Searching for: "${decision.args.query}"...`, true);
                const observation = await googleSearchAction(decision.args);
                const finalPrompt = `Based on this search result: "${observation}", formulate a natural language response to the user's original request: "${userInput}".`;
                finalResponse = await callGeminiText("gemini-2.0-flash", finalPrompt, 0.5);
            } else {
                finalResponse = "I'm not sure how to handle that request.";
            }

            updateLastMessage(finalResponse);
            currentConversation.history.push({ role: 'model', parts: [{ text: finalResponse }] });
        }

        // --- Prompt Engineering ---
        function buildRouterPrompt(userInput, imageData, history) {
            const historyString = history.slice(-6).map(turn => `${turn.role}: ${turn.parts[0].text}`).join('\n');
            const toolDescriptions = `google_search: Useful for when you need to answer questions about current events, facts, or information on the internet.`;
            
            let prompt = `You are a router agent. Your job is to decide the best action to take based on the user's request.\nConversation History:\n${historyString}\nUser's latest request: "${userInput}"\nAvailable Actions:\n1. **chat**: If the request is a greeting, conversational, or something you can answer from general knowledge.\n2. **vision**: If an image is provided. **ONLY use this if an image is present.**\n3. **tool_use**: If the request requires up-to-date information from the internet.\n**Available Tools for 'tool_use':**\n- ${toolDescriptions}\nYou MUST respond with a single JSON object in a markdown code block.`;
            
            if (imageData) {
                 prompt += `\n**Image has been provided.**\nResponse format for vision: \`\`\`json\n{"action": "vision"}\`\`\``;
            } else {
                 prompt += `\nResponse format for chat: \`\`\`json\n{"action": "chat", "response": "Your natural language response."}\`\`\`\nResponse format for tool use: \`\`\`json\n{"action": "tool_use", "tool": "google_search", "args": {"query": "The user's search query"}}\`\`\``;
            }
            return prompt;
        }

        // --- Tool Definitions ---
        async function googleSearchAction(args) {
            const searchPrompt = `Provide a concise answer for the search query: "${args.query}".`;
            return await callGeminiText("gemini-2.0-flash", searchPrompt, 0.5);
        }

        // --- API Call Functions ---
        async function callGeminiText(model, prompt, temperature = 0.2) {
             const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
             return await callGemini(model, payload);
        }
        async function callGeminiVision(model, prompt, mimeType, base64Data) {
            const payload = { contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType, data: base64Data } }] }] };
            return await callGemini(model, payload);
        }
        
        async function callGemini(model, payload) {
            try {
                // The API_BASE_URL now points to our Lambda via API Gateway
                const response = await fetch(API_BASE_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: model, payload: payload }) // Pass model and payload to Lambda
                });
    
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `API call failed with status: ${response.status}`);
                }
    
                // The Lambda function now returns the full response from Gemini,
                // so we need to parse it again here.
                const data = await response.json();
    
                if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts) {
                    return data.candidates[0].content.parts[0].text;
                }
    
                const blockReason = data.promptFeedback?.blockReason;
                if (blockReason) {
                    throw new Error(`API call blocked due to: ${blockReason}. Please check safety settings.`);
                }
                throw new Error(`API call returned no candidates or unexpected format.`);
    
            } catch (error) {
                console.error("Error calling backend API:", error);
                return `Error: ${error.message}`;
            }
        }
        
        // --- UI & State Functions ---
        function addChatMessage({ role, text, thinking = false }) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message flex w-full items-start gap-4`;
            
            let contentHTML = '';
            const sanitizedText = text ? text.replace(/</g, "&lt;").replace(/>/g, "&gt;") : '';

            if (role === 'user') {
                messageDiv.classList.add('flex-row-reverse');
                const userIcon = `<div class="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center text-white font-bold text-sm flex-shrink-0">U</div>`;
                contentHTML = `<div class="p-3 rounded-lg bg-blue-100 dark:bg-blue-900/40 text-gray-800 dark:text-gray-200">${sanitizedText}</div>${userIcon}`;
            } else { // agent
                const agentIcon = `<div class="w-8 h-8 rounded-full bg-gray-200 dark:bg-gray-700 flex items-center justify-center flex-shrink-0"><svg class="gemini-gradient-text" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M12,2A10,10,0,0,0,2,12A10,10,0,0,0,12,22A10,10,0,0,0,22,12A10,10,0,0,0,12,2ZM15.1,17.5H8.9V15.8H15.1V17.5ZM15.1,14.2H8.9V12.5H15.1V14.2ZM17.8,9.2L16.5,10.5L15.2,9.2L14,10.5L12.8,9.2L11.5,10.5L10.2,9.2L9,10.5L7.8,9.2L6.5,10.5V6.5H17.8V9.2Z"></path></svg></div>`;
                const textDiv = `<div class="p-3 rounded-lg bg-gray-100 dark:bg-[#1e1f20]">${thinking ? '<span class="thinking-dots"><span>.</span><span>.</span><span>.</span></span>' : sanitizedText.replace(/\n/g, '<br>')}</div>`;
                contentHTML = `${agentIcon}${textDiv}`;
            }
            messageDiv.innerHTML = contentHTML;
            chatLog.appendChild(messageDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
        }
        
        function updateLastMessage(text, isSystemMessage = false) {
            const lastMessage = chatLog.lastElementChild;
            if (!lastMessage) return;
            const sanitizedText = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            if(isSystemMessage) {
                lastMessage.innerHTML = `<div class="w-full text-center text-xs italic text-gray-500 dark:text-gray-400 py-2">${sanitizedText}</div>`;
            } else {
                 const textContainer = lastMessage.querySelector('.bg-gray-100, .dark\\:bg-\\[\\#1e1f20\\]');
                 if(textContainer) {
                    textContainer.innerHTML = sanitizedText.replace(/\n/g, '<br>');
                 }
            }
        }
        
        function createNewChat() {
            const newId = `chat_${Date.now()}`;
            conversations[newId] = { id: newId, title: "New Chat", history: [] };
            switchConversation(newId);
        }

        function switchConversation(id) {
            activeConversationId = id;
            chatLog.innerHTML = '';
            const conversation = conversations[id];
            
            if (conversation.history.length === 0) {
                 addChatMessage({role: 'agent', text: 'Hello! How can I help you today?'});
            } else {
                 conversation.history.forEach(turn => {
                    const message = { role: turn.role, text: turn.parts[0].text };
                    addChatMessage(message);
                 });
            }
            renderSidebar();
        }

        function renderSidebar() {
            chatHistoryList.innerHTML = '';
            Object.values(conversations).reverse().forEach(convo => {
                const item = document.createElement('a');
                item.href = "#";
                item.className = `sidebar-item block p-2 text-sm rounded-lg truncate transition-colors ${convo.id === activeConversationId ? 'active font-semibold' : 'hover:bg-gray-200 dark:hover:bg-[#2d2e30]'}`;
                item.textContent = convo.title;
                item.dataset.id = convo.id;
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    switchConversation(convo.id);
                });
                chatHistoryList.appendChild(item);
            });
        }
        
        // --- Event Listeners ---
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const userInput = chatInput.value.trim();
            if (!userInput && !currentImageData) return;
            
            runAgent(userInput || 'Describe this image', currentImageData);
            
            chatInput.value = '';
            chatInput.style.height = 'auto';
            currentImageData = null;
            imagePreviewContainer.classList.add('hidden');
        });
        
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                chatForm.requestSubmit();
            }
        });

        chatInput.addEventListener('input', () => {
            chatInput.style.height = 'auto';
            chatInput.style.height = `${chatInput.scrollHeight}px`;
        });
        
        attachFileBtn.addEventListener('click', () => imageUpload.click());
        
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const dataUrl = e.target.result;
                imagePreview.src = dataUrl;
                imagePreviewContainer.classList.remove('hidden');
                currentImageData = { base64: dataUrl.split(',')[1], mimeType: file.type };
            };
            reader.readAsDataURL(file);
        });
        
        removeImageBtn.addEventListener('click', () => {
             currentImageData = null;
             imagePreviewContainer.classList.add('hidden');
             imageUpload.value = ''; // Reset file input
        });

        newChatBtn.addEventListener('click', createNewChat);
        
        // --- Initial Load ---
        createNewChat();

    </script>
</body>
</html>
